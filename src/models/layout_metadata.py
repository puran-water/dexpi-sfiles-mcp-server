"""Layout metadata for persisting graph node positions.

This module provides schemas for persisting layout information generated by
upstream positioning utilities (like SFILES2's _add_positions). It does NOT
implement layout algorithms - it validates and serializes the output.

Architecture Decision (Codex Review #3):
    "Don't build new layout algorithms. Persist the output of SFILES2's
    _add_positions utility which already provides deterministic positioning."

Upstream Integration:
    - SFILES2: Uses _add_positions(g, layout='spring') to add 'pos' attributes
    - pyDEXPI: MLGraphLoader also uses _add_positions for consistent layout

This module validates those 'pos' attributes and provides additional layout
metadata for persistence and rendering.
"""

import logging
from typing import Any, Dict, List, Optional, Tuple
from pydantic import BaseModel, Field, field_validator

logger = logging.getLogger(__name__)


class NodePosition(BaseModel):
    """Position of a single node in 2D layout space.

    Attributes:
        x: Horizontal coordinate
        y: Vertical coordinate
        z: Optional depth coordinate (for 3D layouts)
    """

    x: float = Field(..., description="Horizontal coordinate")
    y: float = Field(..., description="Vertical coordinate")
    z: Optional[float] = Field(None, description="Depth coordinate (optional for 3D)")

    @classmethod
    def from_list(cls, pos: List[float]) -> "NodePosition":
        """Create NodePosition from [x, y] or [x, y, z] list.

        Args:
            pos: Position as [x, y] or [x, y, z]

        Returns:
            NodePosition instance

        Raises:
            ValueError: If pos doesn't have 2 or 3 elements
        """
        if len(pos) == 2:
            return cls(x=pos[0], y=pos[1])
        elif len(pos) == 3:
            return cls(x=pos[0], y=pos[1], z=pos[2])
        else:
            raise ValueError(f"Position must be [x, y] or [x, y, z], got {len(pos)} elements")

    def to_list(self, include_z: bool = False) -> List[float]:
        """Convert to list format [x, y] or [x, y, z].

        Args:
            include_z: Include z coordinate even if None (as 0.0)

        Returns:
            Position as list
        """
        if include_z or self.z is not None:
            return [self.x, self.y, self.z or 0.0]
        return [self.x, self.y]


class BoundingBox(BaseModel):
    """Bounding box for a node or entire graph.

    Attributes:
        min_x: Minimum x coordinate
        max_x: Maximum x coordinate
        min_y: Minimum y coordinate
        max_y: Maximum y coordinate
        width: Computed width (max_x - min_x)
        height: Computed height (max_y - min_y)
    """

    min_x: float = Field(..., description="Minimum x coordinate")
    max_x: float = Field(..., description="Maximum x coordinate")
    min_y: float = Field(..., description="Minimum y coordinate")
    max_y: float = Field(..., description="Maximum y coordinate")

    @property
    def width(self) -> float:
        """Computed width of bounding box."""
        return self.max_x - self.min_x

    @property
    def height(self) -> float:
        """Computed height of bounding box."""
        return self.max_y - self.min_y

    @property
    def center(self) -> Tuple[float, float]:
        """Computed center point of bounding box."""
        return (
            (self.min_x + self.max_x) / 2,
            (self.min_y + self.max_y) / 2
        )

    @classmethod
    def from_positions(cls, positions: Dict[str, NodePosition]) -> "BoundingBox":
        """Compute bounding box from node positions.

        Args:
            positions: Dictionary of node_id -> NodePosition

        Returns:
            BoundingBox encompassing all positions

        Raises:
            ValueError: If positions is empty
        """
        if not positions:
            raise ValueError("Cannot compute bounding box from empty positions")

        x_coords = [pos.x for pos in positions.values()]
        y_coords = [pos.y for pos in positions.values()]

        return cls(
            min_x=min(x_coords),
            max_x=max(x_coords),
            min_y=min(y_coords),
            max_y=max(y_coords)
        )


class LayoutMetadata(BaseModel):
    """Layout metadata for a graph with positioned nodes.

    This schema validates and persists layout information generated by upstream
    utilities (SFILES2's _add_positions, pyDEXPI's positioning, etc.).

    Attributes:
        algorithm: Layout algorithm used (e.g., 'spring', 'hierarchical', 'manual')
        positions: Dictionary of node_id -> NodePosition
        bounding_box: Overall bounding box of the layout
        parameters: Optional algorithm-specific parameters used
        timestamp: Optional timestamp when layout was computed
    """

    algorithm: str = Field(
        ...,
        description="Layout algorithm used (spring, hierarchical, manual, etc.)"
    )

    positions: Dict[str, NodePosition] = Field(
        ...,
        description="Node positions keyed by node ID"
    )

    bounding_box: Optional[BoundingBox] = Field(
        None,
        description="Overall bounding box (auto-computed if not provided)"
    )

    parameters: Optional[Dict[str, Any]] = Field(
        None,
        description="Algorithm-specific parameters (iterations, k-value, seed, etc.)"
    )

    timestamp: Optional[str] = Field(
        None,
        description="ISO 8601 timestamp when layout was computed"
    )

    @field_validator('positions')
    @classmethod
    def validate_positions_not_empty(cls, v: Dict[str, NodePosition]) -> Dict[str, NodePosition]:
        """Validate that positions dictionary is not empty."""
        if not v:
            raise ValueError("Layout must have at least one positioned node")
        return v

    def model_post_init(self, __context) -> None:
        """Compute bounding box if not provided."""
        if self.bounding_box is None and self.positions:
            self.bounding_box = BoundingBox.from_positions(self.positions)

    @classmethod
    def from_networkx_graph(
        cls,
        graph,
        algorithm: str = "spring",
        parameters: Optional[Dict[str, Any]] = None
    ) -> "LayoutMetadata":
        """Extract layout metadata from NetworkX graph with 'pos' attributes.

        Args:
            graph: NetworkX graph with 'pos' attributes on nodes
            algorithm: Layout algorithm name to record
            parameters: Optional algorithm parameters to record

        Returns:
            LayoutMetadata instance

        Raises:
            ValueError: If any node is missing 'pos' attribute
        """
        positions = {}

        for node_id, attrs in graph.nodes(data=True):
            if 'pos' not in attrs:
                raise ValueError(f"Node {node_id} is missing 'pos' attribute")

            pos_list = attrs['pos']
            positions[node_id] = NodePosition.from_list(pos_list)

        return cls(
            algorithm=algorithm,
            positions=positions,
            parameters=parameters
        )

    def apply_to_networkx_graph(self, graph) -> None:
        """Apply layout positions to NetworkX graph as 'pos' attributes.

        Args:
            graph: NetworkX graph to update

        Note:
            Only updates nodes that exist in both the layout and the graph.
            Logs a warning for any missing nodes.
        """
        for node_id, position in self.positions.items():
            if node_id not in graph.nodes:
                logger.warning(f"Layout has position for {node_id} but node not in graph")
                continue

            graph.nodes[node_id]['pos'] = position.to_list()

    def to_dict(self, exclude_none: bool = True) -> Dict[str, Any]:
        """Export to dict with deterministic key ordering.

        Args:
            exclude_none: If True, exclude None values from output

        Returns:
            Dictionary with sorted keys for git-friendly diffs
        """
        # Convert to dict
        data = self.model_dump(exclude_none=exclude_none)

        # Convert nested NodePosition objects to lists
        if 'positions' in data:
            data['positions'] = {
                node_id: NodePosition(**pos_data).to_list()
                for node_id, pos_data in data['positions'].items()
            }

        # Sort top-level keys
        return dict(sorted(data.items()))


class LayoutCollection(BaseModel):
    """Collection of multiple layouts for the same graph.

    Useful for storing different layout algorithms or user-customized versions.

    Attributes:
        default_layout: Name of the default layout to use
        layouts: Dictionary of layout_name -> LayoutMetadata
    """

    default_layout: str = Field(
        ...,
        description="Name of the default layout"
    )

    layouts: Dict[str, LayoutMetadata] = Field(
        ...,
        description="Available layouts keyed by name"
    )

    @field_validator('layouts')
    @classmethod
    def validate_layouts_not_empty(cls, v: Dict[str, LayoutMetadata]) -> Dict[str, LayoutMetadata]:
        """Validate that layouts dictionary is not empty."""
        if not v:
            raise ValueError("LayoutCollection must have at least one layout")
        return v

    def model_post_init(self, __context) -> None:
        """Validate that default_layout exists in layouts."""
        if self.default_layout not in self.layouts:
            raise ValueError(
                f"default_layout '{self.default_layout}' not found in layouts. "
                f"Available: {list(self.layouts.keys())}"
            )

    def get_default(self) -> LayoutMetadata:
        """Get the default layout.

        Returns:
            Default LayoutMetadata instance
        """
        return self.layouts[self.default_layout]

    def add_layout(self, name: str, layout: LayoutMetadata, set_as_default: bool = False) -> None:
        """Add a layout to the collection.

        Args:
            name: Name for the layout
            layout: LayoutMetadata to add
            set_as_default: If True, set this as the default layout
        """
        self.layouts[name] = layout
        if set_as_default:
            self.default_layout = name


__all__ = [
    "NodePosition",
    "BoundingBox",
    "LayoutMetadata",
    "LayoutCollection",
]
